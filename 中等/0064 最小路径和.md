0064. 最小路径和

- 中等

## 题目描述：
给定一个包含非负整数的 *m* x *n* 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明**：每次只能向下或者向右移动一步。

- 示例：

```
输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。
```

## 我的解答：
``` python
class Solution(object):
    # 用时96ms
    def minPathSum(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        # 第一行 & 第一列只能来自左或者上
        for i in range(1, len(grid[0])):
            grid[0][i] += grid[0][i - 1]
        for i in range(1, len(grid)):
            grid[i][0] += grid[i - 1][0]
        # 中间的来自左或者上两者的最小
        for i in range(1, len(grid)):
            for j in range(1, len(grid[0])):
                grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])
        return grid[-1][-1]
```

```ruby
# @param {Integer[][]} grid
# @return {Integer}
def min_path_sum(grid)
    m = grid.size
    n = grid[0].size
    (1...m).each {|i| grid[i][0] += grid[i - 1][0]}
    (1...n).each {|i| grid[0][i] += grid[0][i - 1]}
    (1...m).each do |i|
        (1...n).each do |j|
            grid[i][j] += [grid[i - 1][j], grid[i][j - 1]].min
        end
    end
    grid[-1][-1]
end
```

```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        // 用时16ms
        int column = grid.size(), row = grid[0].size();
        for(int i = 1; i < row; i++) grid[0][i] += grid[0][i - 1];
        for(int i = 1; i < column; i++) grid[i][0] += grid[i - 1][0];
        for(int i = 1; i < column; i++){
            for(int j = 1; j < row; j++){
                grid[i][j] += grid[i - 1][j] < grid[i][j - 1]? grid[i - 1][j]:grid[i][j - 1];
            }
        }
        return grid[column - 1][row - 1];
    }
};
```

## 最快解答：
``` python
class Solution(object):
    # 用时76ms
    def minPathSum(self, grid):
        for i in range(1,len(grid[0])):
            grid[0][i]+=grid[0][i-1]
        for j in range(1,len(grid)):
            grid[j][0]+=grid[j-1][0]
        for i in range(1,len(grid)):
            for j in range(1,len(grid[0])):
                grid[i][j]+=min(grid[i-1][j],grid[i][j-1])
        return grid[-1][-1]
```

```cpp
public:
    // 用时0ms
int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        for(int i = 1; i < m; ++i)
            grid[i][0] += grid[i-1][0];
        for(int j = 1; j < n; ++j)
            grid[0][j] += grid[0][j-1];
        for(int i = 1; i < m; ++i){
            for(int j = 1; j < n; ++j)
                grid[i][j] += std::min(grid[i][j-1], grid[i-1][j]);
        }
        return grid.back().back();
    }
};
```
